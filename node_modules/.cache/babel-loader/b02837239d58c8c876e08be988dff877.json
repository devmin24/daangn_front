{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _values from \"lodash-es/values\";\nimport _get from \"lodash-es/get\";\nimport _has from \"lodash-es/has\";\nimport _forEach from \"lodash-es/forEach\";\nimport _mapValues from \"lodash-es/mapValues\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { getElementType, getUnhandledProps, SUI } from '../../lib';\nimport { getChildMapping, mergeChildMappings } from './utils/childMapping';\nimport wrapChild from './utils/wrapChild';\n/**\n * A Transition.Group animates children as they mount and unmount.\n */\n\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n\n  function TransitionGroup() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()\n      handleOnHide: function handleOnHide(nothing, childProps) {\n        var reactKey = childProps.reactKey;\n\n        _this.setState(function (state) {\n          var children = _extends({}, state.children);\n\n          delete children[reactKey];\n          return {\n            children: children\n          };\n        });\n      }\n    };\n    return _this;\n  }\n\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var animation = props.animation,\n        duration = props.duration,\n        directional = props.directional;\n    var prevMapping = state.children; // A short circuit for an initial render as there will be no `prevMapping`\n\n    if (typeof prevMapping === 'undefined') {\n      return {\n        children: _mapValues(getChildMapping(props.children), function (child) {\n          return wrapChild(child, state.handleOnHide, {\n            animation: animation,\n            duration: duration,\n            directional: directional\n          });\n        })\n      };\n    }\n\n    var nextMapping = getChildMapping(props.children);\n    var children = mergeChildMappings(prevMapping, nextMapping);\n\n    _forEach(children, function (child, key) {\n      var hasPrev = _has(prevMapping, key);\n\n      var hasNext = _has(nextMapping, key);\n\n      var prevChild = prevMapping[key];\n      var isLeaving = !_get(prevChild, 'props.visible'); // Heads up!\n      // An item is new (entering), it will be picked from `nextChildren`, so it should be wrapped\n\n      if (hasNext && (!hasPrev || isLeaving)) {\n        children[key] = wrapChild(child, state.handleOnHide, {\n          animation: animation,\n          duration: duration,\n          directional: directional,\n          transitionOnMount: true\n        });\n        return;\n      } // Heads up!\n      // An item is old (exiting), it will be picked from `prevChildren`, so it has been already\n      // wrapped, so should be only updated\n\n\n      if (!hasNext && hasPrev && !isLeaving) {\n        children[key] = /*#__PURE__*/React.cloneElement(prevChild, {\n          visible: false\n        });\n        return;\n      } // Heads up!\n      // An item item hasn't changed transition states, but it will be picked from `nextChildren`,\n      // so we should wrap it again\n\n\n      var _prevChild$props = prevChild.props,\n          visible = _prevChild$props.visible,\n          transitionOnMount = _prevChild$props.transitionOnMount;\n      children[key] = wrapChild(child, state.handleOnHide, {\n        animation: animation,\n        duration: duration,\n        directional: directional,\n        transitionOnMount: transitionOnMount,\n        visible: visible\n      });\n    });\n\n    return {\n      children: children\n    };\n  };\n\n  var _proto = TransitionGroup.prototype;\n\n  _proto.render = function render() {\n    var children = this.state.children;\n    var ElementType = getElementType(TransitionGroup, this.props);\n    var rest = getUnhandledProps(TransitionGroup, this.props);\n    return /*#__PURE__*/React.createElement(ElementType, rest, _values(children));\n  };\n\n  return TransitionGroup;\n}(React.Component);\n\nTransitionGroup.handledProps = [\"animation\", \"as\", \"children\", \"directional\", \"duration\"];\nexport { TransitionGroup as default };\nTransitionGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** An element type to render as (string or function). */\n  as: PropTypes.elementType,\n\n  /** Named animation event to used. Must be defined in CSS. */\n  animation: PropTypes.oneOfType([PropTypes.oneOf(SUI.TRANSITIONS), PropTypes.string]),\n\n  /** Primary content. */\n  children: PropTypes.node,\n\n  /** Whether it is directional animation event or not. Use it only for custom transitions. */\n  directional: PropTypes.bool,\n\n  /** Duration of the CSS transition animation in milliseconds. */\n  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    hide: PropTypes.number.isRequired,\n    show: PropTypes.number.isRequired\n  }), PropTypes.string])\n} : {};\nTransitionGroup.defaultProps = {\n  as: React.Fragment,\n  animation: 'fade',\n  duration: 500\n};","map":{"version":3,"sources":["/Users/parkminkyung/sparta_react/daangnmarket/node_modules/semantic-ui-react/dist/es/modules/Transition/TransitionGroup.js"],"names":["_extends","_inheritsLoose","_values","_get","_has","_forEach","_mapValues","PropTypes","React","getElementType","getUnhandledProps","SUI","getChildMapping","mergeChildMappings","wrapChild","TransitionGroup","_React$Component","_this","_len","arguments","length","args","Array","_key","call","apply","concat","state","handleOnHide","nothing","childProps","reactKey","setState","children","getDerivedStateFromProps","props","animation","duration","directional","prevMapping","child","nextMapping","key","hasPrev","hasNext","prevChild","isLeaving","transitionOnMount","cloneElement","visible","_prevChild$props","_proto","prototype","render","ElementType","rest","createElement","Component","handledProps","default","propTypes","process","env","NODE_ENV","as","elementType","oneOfType","oneOf","TRANSITIONS","string","node","bool","number","shape","hide","isRequired","show","defaultProps","Fragment"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _values from \"lodash-es/values\";\nimport _get from \"lodash-es/get\";\nimport _has from \"lodash-es/has\";\nimport _forEach from \"lodash-es/forEach\";\nimport _mapValues from \"lodash-es/mapValues\";\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { getElementType, getUnhandledProps, SUI } from '../../lib';\nimport { getChildMapping, mergeChildMappings } from './utils/childMapping';\nimport wrapChild from './utils/wrapChild';\n\n/**\n * A Transition.Group animates children as they mount and unmount.\n */\nvar TransitionGroup = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TransitionGroup, _React$Component);\n\n  function TransitionGroup() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()\n      handleOnHide: function handleOnHide(nothing, childProps) {\n        var reactKey = childProps.reactKey;\n\n        _this.setState(function (state) {\n          var children = _extends({}, state.children);\n\n          delete children[reactKey];\n          return {\n            children: children\n          };\n        });\n      }\n    };\n    return _this;\n  }\n\n  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var animation = props.animation,\n        duration = props.duration,\n        directional = props.directional;\n    var prevMapping = state.children; // A short circuit for an initial render as there will be no `prevMapping`\n\n    if (typeof prevMapping === 'undefined') {\n      return {\n        children: _mapValues(getChildMapping(props.children), function (child) {\n          return wrapChild(child, state.handleOnHide, {\n            animation: animation,\n            duration: duration,\n            directional: directional\n          });\n        })\n      };\n    }\n\n    var nextMapping = getChildMapping(props.children);\n    var children = mergeChildMappings(prevMapping, nextMapping);\n\n    _forEach(children, function (child, key) {\n      var hasPrev = _has(prevMapping, key);\n\n      var hasNext = _has(nextMapping, key);\n\n      var prevChild = prevMapping[key];\n      var isLeaving = !_get(prevChild, 'props.visible'); // Heads up!\n      // An item is new (entering), it will be picked from `nextChildren`, so it should be wrapped\n\n      if (hasNext && (!hasPrev || isLeaving)) {\n        children[key] = wrapChild(child, state.handleOnHide, {\n          animation: animation,\n          duration: duration,\n          directional: directional,\n          transitionOnMount: true\n        });\n        return;\n      } // Heads up!\n      // An item is old (exiting), it will be picked from `prevChildren`, so it has been already\n      // wrapped, so should be only updated\n\n\n      if (!hasNext && hasPrev && !isLeaving) {\n        children[key] = /*#__PURE__*/React.cloneElement(prevChild, {\n          visible: false\n        });\n        return;\n      } // Heads up!\n      // An item item hasn't changed transition states, but it will be picked from `nextChildren`,\n      // so we should wrap it again\n\n\n      var _prevChild$props = prevChild.props,\n          visible = _prevChild$props.visible,\n          transitionOnMount = _prevChild$props.transitionOnMount;\n      children[key] = wrapChild(child, state.handleOnHide, {\n        animation: animation,\n        duration: duration,\n        directional: directional,\n        transitionOnMount: transitionOnMount,\n        visible: visible\n      });\n    });\n\n    return {\n      children: children\n    };\n  };\n\n  var _proto = TransitionGroup.prototype;\n\n  _proto.render = function render() {\n    var children = this.state.children;\n    var ElementType = getElementType(TransitionGroup, this.props);\n    var rest = getUnhandledProps(TransitionGroup, this.props);\n    return /*#__PURE__*/React.createElement(ElementType, rest, _values(children));\n  };\n\n  return TransitionGroup;\n}(React.Component);\n\nTransitionGroup.handledProps = [\"animation\", \"as\", \"children\", \"directional\", \"duration\"];\nexport { TransitionGroup as default };\nTransitionGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** An element type to render as (string or function). */\n  as: PropTypes.elementType,\n\n  /** Named animation event to used. Must be defined in CSS. */\n  animation: PropTypes.oneOfType([PropTypes.oneOf(SUI.TRANSITIONS), PropTypes.string]),\n\n  /** Primary content. */\n  children: PropTypes.node,\n\n  /** Whether it is directional animation event or not. Use it only for custom transitions. */\n  directional: PropTypes.bool,\n\n  /** Duration of the CSS transition animation in milliseconds. */\n  duration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    hide: PropTypes.number.isRequired,\n    show: PropTypes.number.isRequired\n  }), PropTypes.string])\n} : {};\nTransitionGroup.defaultProps = {\n  as: React.Fragment,\n  animation: 'fade',\n  duration: 500\n};"]},"metadata":{},"sourceType":"module"}