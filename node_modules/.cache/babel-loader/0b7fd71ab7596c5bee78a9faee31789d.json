{"ast":null,"code":"import { DEFAULT_NAMESPACE, ACTION_TYPE_DELIMITER } from '../constants';\nimport ownKeys from './ownKeys';\nimport get from './get';\nexport default (function (predicate) {\n  return function flatten(map, _temp, partialFlatMap, partialFlatActionType) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$namespace = _ref.namespace,\n        namespace = _ref$namespace === void 0 ? DEFAULT_NAMESPACE : _ref$namespace,\n        prefix = _ref.prefix;\n\n    if (partialFlatMap === void 0) {\n      partialFlatMap = {};\n    }\n\n    if (partialFlatActionType === void 0) {\n      partialFlatActionType = '';\n    }\n\n    function connectNamespace(type) {\n      var _ref2;\n\n      if (!partialFlatActionType) return type;\n      var types = type.toString().split(ACTION_TYPE_DELIMITER);\n      var partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER);\n      return (_ref2 = []).concat.apply(_ref2, partials.map(function (p) {\n        return types.map(function (t) {\n          return \"\" + p + namespace + t;\n        });\n      })).join(ACTION_TYPE_DELIMITER);\n    }\n\n    function connectPrefix(type) {\n      if (partialFlatActionType || !prefix || prefix && new RegExp(\"^\" + prefix + namespace).test(type)) {\n        return type;\n      }\n\n      return \"\" + prefix + namespace + type;\n    }\n\n    ownKeys(map).forEach(function (type) {\n      var nextNamespace = connectPrefix(connectNamespace(type));\n      var mapValue = get(type, map);\n\n      if (predicate(mapValue)) {\n        flatten(mapValue, {\n          namespace: namespace,\n          prefix: prefix\n        }, partialFlatMap, nextNamespace);\n      } else {\n        partialFlatMap[nextNamespace] = mapValue;\n      }\n    });\n    return partialFlatMap;\n  };\n});","map":{"version":3,"sources":["/Users/parkminkyung/sparta_react/daangnmarket/node_modules/redux-actions/es/utils/flattenWhenNode.js"],"names":["DEFAULT_NAMESPACE","ACTION_TYPE_DELIMITER","ownKeys","get","predicate","flatten","map","_temp","partialFlatMap","partialFlatActionType","_ref","_ref$namespace","namespace","prefix","connectNamespace","type","_ref2","types","toString","split","partials","concat","apply","p","t","join","connectPrefix","RegExp","test","forEach","nextNamespace","mapValue"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,qBAA5B,QAAyD,cAAzD;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,gBAAgB,UAAUC,SAAV,EAAqB;AACnC,SAAO,SAASC,OAAT,CAAiBC,GAAjB,EAAsBC,KAAtB,EAA6BC,cAA7B,EAA6CC,qBAA7C,EAAoE;AACzE,QAAIC,IAAI,GAAGH,KAAK,KAAK,KAAK,CAAf,GAAmB,EAAnB,GAAwBA,KAAnC;AAAA,QACII,cAAc,GAAGD,IAAI,CAACE,SAD1B;AAAA,QAEIA,SAAS,GAAGD,cAAc,KAAK,KAAK,CAAxB,GAA4BX,iBAA5B,GAAgDW,cAFhE;AAAA,QAGIE,MAAM,GAAGH,IAAI,CAACG,MAHlB;;AAKA,QAAIL,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAC7BA,MAAAA,cAAc,GAAG,EAAjB;AACD;;AAED,QAAIC,qBAAqB,KAAK,KAAK,CAAnC,EAAsC;AACpCA,MAAAA,qBAAqB,GAAG,EAAxB;AACD;;AAED,aAASK,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,UAAIC,KAAJ;;AAEA,UAAI,CAACP,qBAAL,EAA4B,OAAOM,IAAP;AAC5B,UAAIE,KAAK,GAAGF,IAAI,CAACG,QAAL,GAAgBC,KAAhB,CAAsBlB,qBAAtB,CAAZ;AACA,UAAImB,QAAQ,GAAGX,qBAAqB,CAACU,KAAtB,CAA4BlB,qBAA5B,CAAf;AACA,aAAO,CAACe,KAAK,GAAG,EAAT,EAAaK,MAAb,CAAoBC,KAApB,CAA0BN,KAA1B,EAAiCI,QAAQ,CAACd,GAAT,CAAa,UAAUiB,CAAV,EAAa;AAChE,eAAON,KAAK,CAACX,GAAN,CAAU,UAAUkB,CAAV,EAAa;AAC5B,iBAAO,KAAKD,CAAL,GAASX,SAAT,GAAqBY,CAA5B;AACD,SAFM,CAAP;AAGD,OAJuC,CAAjC,EAIHC,IAJG,CAIExB,qBAJF,CAAP;AAKD;;AAED,aAASyB,aAAT,CAAuBX,IAAvB,EAA6B;AAC3B,UAAIN,qBAAqB,IAAI,CAACI,MAA1B,IAAoCA,MAAM,IAAI,IAAIc,MAAJ,CAAW,MAAMd,MAAN,GAAeD,SAA1B,EAAqCgB,IAArC,CAA0Cb,IAA1C,CAAlD,EAAmG;AACjG,eAAOA,IAAP;AACD;;AAED,aAAO,KAAKF,MAAL,GAAcD,SAAd,GAA0BG,IAAjC;AACD;;AAEDb,IAAAA,OAAO,CAACI,GAAD,CAAP,CAAauB,OAAb,CAAqB,UAAUd,IAAV,EAAgB;AACnC,UAAIe,aAAa,GAAGJ,aAAa,CAACZ,gBAAgB,CAACC,IAAD,CAAjB,CAAjC;AACA,UAAIgB,QAAQ,GAAG5B,GAAG,CAACY,IAAD,EAAOT,GAAP,CAAlB;;AAEA,UAAIF,SAAS,CAAC2B,QAAD,CAAb,EAAyB;AACvB1B,QAAAA,OAAO,CAAC0B,QAAD,EAAW;AAChBnB,UAAAA,SAAS,EAAEA,SADK;AAEhBC,UAAAA,MAAM,EAAEA;AAFQ,SAAX,EAGJL,cAHI,EAGYsB,aAHZ,CAAP;AAID,OALD,MAKO;AACLtB,QAAAA,cAAc,CAACsB,aAAD,CAAd,GAAgCC,QAAhC;AACD;AACF,KAZD;AAaA,WAAOvB,cAAP;AACD,GAjDD;AAkDD,CAnDD","sourcesContent":["import { DEFAULT_NAMESPACE, ACTION_TYPE_DELIMITER } from '../constants';\nimport ownKeys from './ownKeys';\nimport get from './get';\nexport default (function (predicate) {\n  return function flatten(map, _temp, partialFlatMap, partialFlatActionType) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$namespace = _ref.namespace,\n        namespace = _ref$namespace === void 0 ? DEFAULT_NAMESPACE : _ref$namespace,\n        prefix = _ref.prefix;\n\n    if (partialFlatMap === void 0) {\n      partialFlatMap = {};\n    }\n\n    if (partialFlatActionType === void 0) {\n      partialFlatActionType = '';\n    }\n\n    function connectNamespace(type) {\n      var _ref2;\n\n      if (!partialFlatActionType) return type;\n      var types = type.toString().split(ACTION_TYPE_DELIMITER);\n      var partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER);\n      return (_ref2 = []).concat.apply(_ref2, partials.map(function (p) {\n        return types.map(function (t) {\n          return \"\" + p + namespace + t;\n        });\n      })).join(ACTION_TYPE_DELIMITER);\n    }\n\n    function connectPrefix(type) {\n      if (partialFlatActionType || !prefix || prefix && new RegExp(\"^\" + prefix + namespace).test(type)) {\n        return type;\n      }\n\n      return \"\" + prefix + namespace + type;\n    }\n\n    ownKeys(map).forEach(function (type) {\n      var nextNamespace = connectPrefix(connectNamespace(type));\n      var mapValue = get(type, map);\n\n      if (predicate(mapValue)) {\n        flatten(mapValue, {\n          namespace: namespace,\n          prefix: prefix\n        }, partialFlatMap, nextNamespace);\n      } else {\n        partialFlatMap[nextNamespace] = mapValue;\n      }\n    });\n    return partialFlatMap;\n  };\n});"]},"metadata":{},"sourceType":"module"}