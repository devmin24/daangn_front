{"ast":null,"code":"import invariant from 'invariant';\nimport isFunction from './utils/isFunction';\nimport isPlainObject from './utils/isPlainObject';\nimport identity from './utils/identity';\nimport isNil from './utils/isNil';\nimport isUndefined from './utils/isUndefined';\nimport toString from './utils/toString';\nimport { ACTION_TYPE_DELIMITER } from './constants';\nexport default function handleAction(type, reducer, defaultState) {\n  if (reducer === void 0) {\n    reducer = identity;\n  }\n\n  var types = toString(type).split(ACTION_TYPE_DELIMITER);\n  invariant(!isUndefined(defaultState), \"defaultState for reducer handling \" + types.join(', ') + \" should be defined\");\n  invariant(isFunction(reducer) || isPlainObject(reducer), 'Expected reducer to be a function or object with next and throw reducers');\n\n  var _ref = isFunction(reducer) ? [reducer, reducer] : [reducer.next, reducer.throw].map(function (aReducer) {\n    return isNil(aReducer) ? identity : aReducer;\n  }),\n      nextReducer = _ref[0],\n      throwReducer = _ref[1];\n\n  return function (state, action) {\n    if (state === void 0) {\n      state = defaultState;\n    }\n\n    var actionType = action.type;\n\n    if (!actionType || types.indexOf(toString(actionType)) === -1) {\n      return state;\n    }\n\n    return (action.error === true ? throwReducer : nextReducer)(state, action);\n  };\n}","map":{"version":3,"sources":["/Users/parkminkyung/sparta_react/daangnmarket/node_modules/redux-actions/es/handleAction.js"],"names":["invariant","isFunction","isPlainObject","identity","isNil","isUndefined","toString","ACTION_TYPE_DELIMITER","handleAction","type","reducer","defaultState","types","split","join","_ref","next","throw","map","aReducer","nextReducer","throwReducer","state","action","actionType","indexOf","error"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,WAAtB;AACA,OAAOC,UAAP,MAAuB,oBAAvB;AACA,OAAOC,aAAP,MAA0B,uBAA1B;AACA,OAAOC,QAAP,MAAqB,kBAArB;AACA,OAAOC,KAAP,MAAkB,eAAlB;AACA,OAAOC,WAAP,MAAwB,qBAAxB;AACA,OAAOC,QAAP,MAAqB,kBAArB;AACA,SAASC,qBAAT,QAAsC,aAAtC;AACA,eAAe,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,OAA5B,EAAqCC,YAArC,EAAmD;AAChE,MAAID,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtBA,IAAAA,OAAO,GAAGP,QAAV;AACD;;AAED,MAAIS,KAAK,GAAGN,QAAQ,CAACG,IAAD,CAAR,CAAeI,KAAf,CAAqBN,qBAArB,CAAZ;AACAP,EAAAA,SAAS,CAAC,CAACK,WAAW,CAACM,YAAD,CAAb,EAA6B,uCAAuCC,KAAK,CAACE,IAAN,CAAW,IAAX,CAAvC,GAA0D,oBAAvF,CAAT;AACAd,EAAAA,SAAS,CAACC,UAAU,CAACS,OAAD,CAAV,IAAuBR,aAAa,CAACQ,OAAD,CAArC,EAAgD,0EAAhD,CAAT;;AAEA,MAAIK,IAAI,GAAGd,UAAU,CAACS,OAAD,CAAV,GAAsB,CAACA,OAAD,EAAUA,OAAV,CAAtB,GAA2C,CAACA,OAAO,CAACM,IAAT,EAAeN,OAAO,CAACO,KAAvB,EAA8BC,GAA9B,CAAkC,UAAUC,QAAV,EAAoB;AAC1G,WAAOf,KAAK,CAACe,QAAD,CAAL,GAAkBhB,QAAlB,GAA6BgB,QAApC;AACD,GAFqD,CAAtD;AAAA,MAGIC,WAAW,GAAGL,IAAI,CAAC,CAAD,CAHtB;AAAA,MAIIM,YAAY,GAAGN,IAAI,CAAC,CAAD,CAJvB;;AAMA,SAAO,UAAUO,KAAV,EAAiBC,MAAjB,EAAyB;AAC9B,QAAID,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,MAAAA,KAAK,GAAGX,YAAR;AACD;;AAED,QAAIa,UAAU,GAAGD,MAAM,CAACd,IAAxB;;AAEA,QAAI,CAACe,UAAD,IAAeZ,KAAK,CAACa,OAAN,CAAcnB,QAAQ,CAACkB,UAAD,CAAtB,MAAwC,CAAC,CAA5D,EAA+D;AAC7D,aAAOF,KAAP;AACD;;AAED,WAAO,CAACC,MAAM,CAACG,KAAP,KAAiB,IAAjB,GAAwBL,YAAxB,GAAuCD,WAAxC,EAAqDE,KAArD,EAA4DC,MAA5D,CAAP;AACD,GAZD;AAaD","sourcesContent":["import invariant from 'invariant';\nimport isFunction from './utils/isFunction';\nimport isPlainObject from './utils/isPlainObject';\nimport identity from './utils/identity';\nimport isNil from './utils/isNil';\nimport isUndefined from './utils/isUndefined';\nimport toString from './utils/toString';\nimport { ACTION_TYPE_DELIMITER } from './constants';\nexport default function handleAction(type, reducer, defaultState) {\n  if (reducer === void 0) {\n    reducer = identity;\n  }\n\n  var types = toString(type).split(ACTION_TYPE_DELIMITER);\n  invariant(!isUndefined(defaultState), \"defaultState for reducer handling \" + types.join(', ') + \" should be defined\");\n  invariant(isFunction(reducer) || isPlainObject(reducer), 'Expected reducer to be a function or object with next and throw reducers');\n\n  var _ref = isFunction(reducer) ? [reducer, reducer] : [reducer.next, reducer.throw].map(function (aReducer) {\n    return isNil(aReducer) ? identity : aReducer;\n  }),\n      nextReducer = _ref[0],\n      throwReducer = _ref[1];\n\n  return function (state, action) {\n    if (state === void 0) {\n      state = defaultState;\n    }\n\n    var actionType = action.type;\n\n    if (!actionType || types.indexOf(toString(actionType)) === -1) {\n      return state;\n    }\n\n    return (action.error === true ? throwReducer : nextReducer)(state, action);\n  };\n}"]},"metadata":{},"sourceType":"module"}